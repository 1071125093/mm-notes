"use strict";(self.webpackChunkmm_notes=self.webpackChunkmm_notes||[]).push([[466],{2476:(e,o,c)=>{c.r(o),c.d(o,{data:()=>d});const d=JSON.parse('{"key":"v-fc48be40","path":"/interview/network/tcp.html","title":"TCP","lang":"zh-CN","frontmatter":{},"excerpt":"","headers":[{"level":2,"title":"三次握手","slug":"三次握手","children":[{"level":3,"title":"第一次握手","slug":"第一次握手","children":[]},{"level":3,"title":"第二次握手","slug":"第二次握手","children":[]},{"level":3,"title":"第三次握手","slug":"第三次握手","children":[]}]},{"level":2,"title":"四次挥手","slug":"四次挥手","children":[{"level":3,"title":"第一次挥手","slug":"第一次挥手","children":[]},{"level":3,"title":"第二次挥手","slug":"第二次挥手","children":[]},{"level":3,"title":"第三次挥手","slug":"第三次挥手","children":[]},{"level":3,"title":"第四次挥手","slug":"第四次挥手","children":[]}]},{"level":2,"title":"TCP 相关学习文章","slug":"tcp-相关学习文章","children":[]}],"git":{"updatedTime":1659957033000},"filePathRelative":"interview/network/tcp.md"}')},6674:(e,o,c)=>{c.r(o),c.d(o,{default:()=>s});var d=c(6252);const i=c.p+"assets/img/tcp-three-handshakes.ed703eef.png",t=c.p+"assets/img/tcp-four-waves.72608ede.png",l=(0,d.uE)('<h1 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp" aria-hidden="true">#</a> TCP</h1><p>TCP（Transmission Control Protocol 传输控制协议）是一个<strong>面向连接的</strong>、<strong>可靠的</strong>、<strong>基于字节流</strong>的传输层通信协议</p><div class="custom-container tip"><p class="custom-container-title">TCP 连接</p><p>TCP 连接是用于保证可靠性和流量控制维护的某些状态信息的组合，这些信息包括 Socket、序列号和窗口大小</p><ul><li><strong>Socket</strong>：由 IP 地址和端口号组成</li><li><strong>序列号</strong>：用来解决乱序问题等</li><li><strong>窗口大小</strong>：用来做流量控制</li></ul></div><div class="custom-container tip"><p class="custom-container-title">TCP 四元组</p><ul><li>源地址</li><li>源端口</li><li>目的地址</li><li>目的端口</li></ul><p>TCP 四元组可以唯一的确定一个连接</p></div><h2 id="三次握手" tabindex="-1"><a class="header-anchor" href="#三次握手" aria-hidden="true">#</a> 三次握手</h2><blockquote><p>TCP 连接建立</p></blockquote><p><strong>三次握手</strong>是指在建立一个 TCP 连接时客户端和服务器总共要<strong>发送 3 个数据包以确认连接的建立</strong></p><p>三次握手的过程如下图所示：</p><p><img src="'+i+'" alt="TCP 三次握手"></p><p>最开始时客户端和服务器都处于 <code>CLOSED</code> 状态。然后服务器主动监听某个端口（此时处于 <code>LISTEN</code> 状态）</p><h3 id="第一次握手" tabindex="-1"><a class="header-anchor" href="#第一次握手" aria-hidden="true">#</a> 第一次握手</h3><blockquote><p><strong>由客户端发起</strong></p></blockquote><p>客户端会随机初始化一个序列号（<code>client_isn</code>）然后发送一个带有 <code>SYN</code> <code>seq = client_isn</code> 信息的数据包。发送完成后客户端进入 <code>SYN_SEND</code> 状态（连接发送状态）</p><ul><li><code>SYN</code> 是一个标志位，为 1 时表示希望建立连接</li><li><code>seq = client_isn</code> 是客户端随机初始化的序列号（一个 32 位的无符号数）</li></ul><h3 id="第二次握手" tabindex="-1"><a class="header-anchor" href="#第二次握手" aria-hidden="true">#</a> 第二次握手</h3><blockquote><p><strong>由服务器发起</strong></p></blockquote><p>服务器收到客户端的 <code>SYN</code> 报文后，首先会随机初始化自己的序列号（<code>server_isn</code>）然后发送一个带有 <code>SYN</code> <code>ACK</code> <code>seq = server_isn</code> <code>ack = client_isn + 1</code> 信息的数据包。发送完成后服务器进入 <code>SYN_RCVD</code> 状态（连接收到状态）</p><ul><li><code>ACK</code> 是一个标志位，表示收到了请求</li><li><code>seq = server_isn</code> 是服务器随机初始化的序列号（一个 32 位的无符号数）</li><li><code>ack = client_isn + 1</code> 是一个确认应答号，值为<strong>客户端序列号 + 1</strong></li></ul><h3 id="第三次握手" tabindex="-1"><a class="header-anchor" href="#第三次握手" aria-hidden="true">#</a> 第三次握手</h3><blockquote><p><strong>由客户端发起</strong></p></blockquote><p>客户端收到服务器报文后，会再发送一个带有 <code>ACK</code> <code>ack = server_isn + 1</code> 信息的数据包。发送完成后客户端进入 <code>ESTABLISHED</code> 状态（连接成功状态）服务器收到客户端发送的应答报文包后也会进入 <code>ESTABLISHED</code> 状态</p><ul><li><code>ack = server_isn + 1</code> 是一个确认应答号，值为<strong>服务器序列号 + 1</strong></li></ul><div class="custom-container tip"><p class="custom-container-title">三次握手可以保证客户端和服务器能够确认双方的接收和发送能力是否正常</p><ul><li>第一次握手：客户端发送 <code>SYN</code> 报文给服务器，服务器接收该报文 <ul><li>客户端什么都不能确认</li><li>服务器确认：自己接收正常，对方发送正常</li></ul></li><li>第二次握手：服务器发送 <code>SYN + ACK</code> 报文给客户端，客户端接收该报文 <ul><li>客户端确认：自己发送正常、接收正常，对方发送正常、接收正常</li><li>服务器确认：自己接收正常，对方发送正常</li></ul></li><li>第三次握手：客户端发送 <code>ACK</code> 报文给服务器 <ul><li>客户端在第二次握手时已经完成确认</li><li>服务器确认：自己发送正常，接收正常，对方发送正常、接收正常</li></ul></li></ul></div><h4 id="三次握手的作用" tabindex="-1"><a class="header-anchor" href="#三次握手的作用" aria-hidden="true">#</a> 三次握手的作用？</h4><ol><li>防止旧的重复连接初始化造成混乱</li><li>同步双方初始序列号（序列号能够保证数据包不重复、不丢弃和按序传输）</li><li>避免资源浪费</li></ol><h4 id="为什么不是两次握手" tabindex="-1"><a class="header-anchor" href="#为什么不是两次握手" aria-hidden="true">#</a> 为什么不是两次握手?</h4><p>两次握手无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号</p><h4 id="为什么不是四次握手" tabindex="-1"><a class="header-anchor" href="#为什么不是四次握手" aria-hidden="true">#</a> 为什么不是四次握手?</h4><p>因为通过前三次已经可以建立一个可靠的连接，如果再发送第四次确认消息会浪费资源，所以不需要使用更多的通信次数</p><h4 id="三次握手过程中-可以携带数据吗" tabindex="-1"><a class="header-anchor" href="#三次握手过程中-可以携带数据吗" aria-hidden="true">#</a> 三次握手过程中，可以携带数据吗？</h4><p>第一次、第二次握手不可以携带数据，第三次握手可以携带数据，因为在第三次握手时客户端已经处于连接状态，已经知道服务器的接收、发送能力是正常的</p><h2 id="四次挥手" tabindex="-1"><a class="header-anchor" href="#四次挥手" aria-hidden="true">#</a> 四次挥手</h2><blockquote><p>TCP 连接断开</p></blockquote><p><strong>四次挥手</strong>是指断开一个 TCP 连接时客户端和服务器总共<strong>发送 4 个包以确认连接的断开</strong><br><strong>客户端和服务器双方都可以主动断开连接</strong></p><p>四次挥手的过程如下图所示：</p><p><img src="'+t+'" alt="TCP 四次挥手"></p><p>最开始时客户端和服务器都处于 <code>ESTABLISHED</code> 状态</p><h3 id="第一次挥手" tabindex="-1"><a class="header-anchor" href="#第一次挥手" aria-hidden="true">#</a> 第一次挥手</h3><p>客户端先发送一个带有 <code>FIN=1</code> 信息的数据包，然后客户端进入 <code>FIN_WAIT_1</code> 状态</p><h3 id="第二次挥手" tabindex="-1"><a class="header-anchor" href="#第二次挥手" aria-hidden="true">#</a> 第二次挥手</h3><p>服务器收到客户端的 <code>FIN</code> 报文后，就向客户端发送 <code>ACK</code> 应答报文，然后服务端进入 <code>CLOSED_WAIT</code> 状态<br> 当客户端收到服务器的 <code>ACK</code> 应答报文后会进入 <code>FIN_WAIT_2</code> 状态</p><h3 id="第三次挥手" tabindex="-1"><a class="header-anchor" href="#第三次挥手" aria-hidden="true">#</a> 第三次挥手</h3><p>当服务器处理完数据后，会向客户端发送 <code>FIN</code> 报文，之后服务器进入 <code>LAST_ACK</code> 状态</p><h3 id="第四次挥手" tabindex="-1"><a class="header-anchor" href="#第四次挥手" aria-hidden="true">#</a> 第四次挥手</h3><p>服务器收到服务端的 <code>FIN</code> 报文后，会回复一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态<br> 服务器收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSED</code> 状态（<strong>服务端完成连接的关闭</strong>）<br> 客户端在经过 <code>2MSL</code> 一段时间后会自动进入 <code>CLOSED</code> 状态（<strong>客户端完成连接的关闭</strong>）</p><div class="custom-container tip"><p class="custom-container-title">什么是 MSL</p><p><code>MSL</code> 是 Maximum Segment Lifetime（<strong>报文最大生存时间</strong>）是任何报文在网络上存在的最长时间，超过这个时间报文将会被丢弃</p><p><code>2MSL</code> 的时间是从客户端接收到 <code>FIN</code> 后发送 <code>ACK</code> 开始计时的。如果在 <code>TIME-WAIT</code> 时间内，因为客户端的 <code>ACK</code> 没有传输到服务端，客户端又接收到了服务端重发的 <code>FIN</code> 报文，那么 <code>2MSL</code> 时间将重新计时</p></div><h4 id="为什么需要-time-wait-状态" tabindex="-1"><a class="header-anchor" href="#为什么需要-time-wait-状态" aria-hidden="true">#</a> 为什么需要 TIME_WAIT 状态？</h4><blockquote><p>主动发起关闭连接的一方才有 <code>TIME-WAIT</code> 状态</p></blockquote><ol><li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</li><li>保证<strong>被动关闭连接</strong>的一方，能被正确的关闭；</li></ol><h4 id="为什么-time-wait-等待的时间是-2msl" tabindex="-1"><a class="header-anchor" href="#为什么-time-wait-等待的时间是-2msl" aria-hidden="true">#</a> 为什么 TIME_WAIT 等待的时间是 2MSL？</h4><ol><li>保证服务端能收到最后的 <code>ACK</code> 应答报文</li><li>让此次 TCP 连接中的所有报文在网络中消失，从而避免前后两个使用相同四元组的连接中的前一个连接的报文干扰后一个连接</li></ol><p>假如客户端在送 <code>ACK</code> 后，这个 <code>ACK</code> 在 <code>1MSL</code> 时到达服务器，此时服务器在收到这个 <code>ACK</code> 的前一刹那，一直在重传 <code>FIN</code>，这个 <code>FIN</code> 最坏会在 <code>1MSL</code> 时间内消失。因此从客户端发送 <code>ACK</code> 的那一刹那开始，等待 <code>2MSL</code> 可以保证客户端发送的最后一个 <code>ACK</code> 和服务器发送的最后一个 <code>FIN</code> 都在网络中消失</p><h2 id="tcp-相关学习文章" tabindex="-1"><a class="header-anchor" href="#tcp-相关学习文章" aria-hidden="true">#</a> TCP 相关学习文章</h2>',53),r={href:"https://xiaolincoding.com/network/3_tcp/tcp_interview.html",target:"_blank",rel:"noopener noreferrer"},a=(0,d.Uk)("TCP 三次握手与四次挥手面试题 —— 小林 coding"),n={},s=(0,c(3744).Z)(n,[["render",function(e,o){const c=(0,d.up)("ExternalLinkIcon");return(0,d.wg)(),(0,d.iD)("div",null,[l,(0,d._)("p",null,[(0,d._)("a",r,[a,(0,d.Wm)(c)])])])}]])},3744:(e,o)=>{o.Z=(e,o)=>{const c=e.__vccOpts||e;for(const[e,d]of o)c[e]=d;return c}}}]);